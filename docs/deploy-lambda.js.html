<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: deploy-lambda.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: deploy-lambda.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Lambda deployment script for the Bedrock demo app.
 * This module handles the creation of IAM roles, deployment of Lambda functions,
 * configuration updates, and creation of function URLs.
 * @module deploy-lambda
 */

const { 
  LambdaClient, 
  CreateFunctionCommand, 
  UpdateFunctionCodeCommand,
  CreateFunctionUrlConfigCommand,
  UpdateFunctionUrlConfigCommand,
  GetFunctionUrlConfigCommand,
  AddPermissionCommand
} = require("@aws-sdk/client-lambda");
const { IAMClient, GetRoleCommand, CreateRoleCommand, AttachRolePolicyCommand } = require("@aws-sdk/client-iam");
const AdmZip = require("adm-zip");
const fs = require("fs");
const path = require('path');
const util = require('util');
const writeFileAsync = util.promisify(fs.writeFile);

/**
 * Parsed configuration object.
 * @type {Object}
 * @property {Object} lambda - Lambda-specific configuration
 * @property {string} lambda.functionName - Name of the Lambda function
 * @property {string} lambda.roleName - Name of the IAM role for the Lambda function
 */
// Read the config file
const configPath = path.join(__dirname, '..', 'config.json');
const rawConfig = fs.readFileSync(configPath);
const config = JSON.parse(rawConfig);

// Extract the function name and role name from the config
const FUNCTION_NAME = config.lambda.functionName;
const ROLE_NAME = config.lambda.roleName;

const REGION = process.env.AWS_REGION || "us-east-1";
const lambda = new LambdaClient({ region: REGION });
const iam = new IAMClient({ region: REGION });

/**
 * Creates an IAM role for the Lambda function.
 * @returns {Promise&lt;string>} The ARN of the created or existing role.
 * @throws {Error} If role creation fails.
 */
async function createLambdaRole() {
  const rolePolicy = {
    Version: "2012-10-17",
    Statement: [
      {
        Effect: "Allow",
        Principal: {
          Service: "lambda.amazonaws.com"
        },
        Action: "sts:AssumeRole"
      }
    ]
  };

  try {
    const getRoleCommand = new GetRoleCommand({ RoleName: ROLE_NAME });
    const { Role } = await iam.send(getRoleCommand);
    return Role.Arn;
  } catch (error) {
    if (error.name === "NoSuchEntityException") {
      const createRoleCommand = new CreateRoleCommand({
        RoleName: ROLE_NAME,
        AssumeRolePolicyDocument: JSON.stringify(rolePolicy)
      });
      const { Role } = await iam.send(createRoleCommand);

      await attachPolicies(ROLE_NAME);

      // Wait for the role to be available
      await new Promise(resolve => setTimeout(resolve, 10000));

      return Role.Arn;
    }
    throw error;
  }
}

/**
 * Attaches necessary policies to the IAM role.
 * @param {string} roleName - The name of the IAM role.
 * @returns {Promise&lt;void>}
 */
async function attachPolicies(roleName) {
  await iam.send(new AttachRolePolicyCommand({
    RoleName: roleName,
    PolicyArn: "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  }));

  await iam.send(new AttachRolePolicyCommand({
    RoleName: roleName,
    PolicyArn: "arn:aws:iam::aws:policy/AmazonBedrockFullAccess"
  }));
}

/**
 * Creates or updates the function URL for the Lambda.
 * @param {string} functionName - The name of the Lambda function.
 * @returns {Promise&lt;void>}
 * @throws {Error} If function URL creation or update fails.
 */
async function createFunctionUrl(functionName) {
  try {
    // Check if function URL already exists
    const getFunctionUrlCommand = new GetFunctionUrlConfigCommand({ FunctionName: functionName });
    await lambda.send(getFunctionUrlCommand);
    
    // If it exists, update it
    const updateFunctionUrlCommand = new UpdateFunctionUrlConfigCommand({
      FunctionName: functionName,
      AuthType: "NONE",
      Cors: {
        AllowCredentials: true,
        AllowHeaders: ["*"],
        AllowMethods: ["*"],
        AllowOrigins: ["*"],
        ExposeHeaders: ["*"],
        MaxAge: 86400
      }
    });
    const response = await lambda.send(updateFunctionUrlCommand);
    console.log("Function URL updated:", response.FunctionUrl);
  } catch (error) {
    if (error.name === "ResourceNotFoundException") {
      // If it doesn't exist, create it
      const createFunctionUrlCommand = new CreateFunctionUrlConfigCommand({
        FunctionName: functionName,
        AuthType: "NONE",
        Cors: {
          AllowCredentials: true,
          AllowHeaders: ["*"],
          AllowMethods: ["*"],
          AllowOrigins: ["*"],
          ExposeHeaders: ["*"],
          MaxAge: 86400
        }
      });
      const response = await lambda.send(createFunctionUrlCommand);
      console.log("Function URL created:", response.FunctionUrl);
    } else {
      throw error;
    }
  }

  // Add permission for public access
  await addFunctionUrlPermission(functionName);
}

/**
 * Adds permission for public access to the function URL.
 * @param {string} functionName - The name of the Lambda function.
 * @returns {Promise&lt;void>}
 * @throws {Error} If adding permission fails.
 */
async function addFunctionUrlPermission(functionName) {
  try {
    const addPermissionCommand = new AddPermissionCommand({
      FunctionName: functionName,
      StatementId: "FunctionURLAllowPublicAccess",
      Action: "lambda:InvokeFunctionUrl",
      Principal: "*",
      FunctionUrlAuthType: "NONE"
    });

    await lambda.send(addPermissionCommand);
    console.log("Function URL public access permission added successfully");
  } catch (error) {
    if (error.name === "ResourceConflictException") {
      console.log("Function URL permission already exists");
    } else {
      throw error;
    }
  }
}

/**
 * Saves the function URL to a config file.
 * @param {string} functionName - The name of the Lambda function.
 * @returns {Promise&lt;void>}
 * @throws {Error} If saving the config fails.
 */
async function SaveUrlInConfigFile(functionName) {
  const command = new GetFunctionUrlConfigCommand({ FunctionName: functionName });

  try {
    const response = await lambda.send(command);

    // Save the function URL to lambdaurl.json
    const lambdaurl = { LAMBDA_FUNCTION_URL: response.FunctionUrl };

    await writeFileAsync('lambdaurl.json', JSON.stringify(lambdaurl, null, 2));
    console.log(`Lambda url file updated at lambdaurl.json`);

  } catch (error) {
    console.error('Error creating and saving lambda url:', error);
    throw error;
  }
}

/**
 * Deploys the Lambda function.
 * @returns {Promise&lt;void>}
 * @throws {Error} If deployment fails.
 */
async function deployLambda() {
  const zip = new AdmZip();
  zip.addLocalFolder("./src");
  const zipBuffer = zip.toBuffer();

  const roleArn = await createLambdaRole();

  try {
    const createFunctionCommand = new CreateFunctionCommand({
      FunctionName: FUNCTION_NAME,
      Runtime: "nodejs18.x",
      Role: roleArn,
      Handler: "index.handler",
      Code: { ZipFile: zipBuffer },
      Timeout: 30,
      MemorySize: 128
    });

    await lambda.send(createFunctionCommand);
    console.log("Lambda function created successfully");
  } catch (error) {
    if (error.name === "ResourceConflictException") {
      console.log("Lambda function already exists. Updating code...");
      const updateFunctionCodeCommand = new UpdateFunctionCodeCommand({
        FunctionName: FUNCTION_NAME,
        ZipFile: zipBuffer
      });
      await lambda.send(updateFunctionCodeCommand);
      console.log("Lambda function code updated successfully");
    } else {
      throw error;
    }
  }

  // Create or update function URL
  await createFunctionUrl(FUNCTION_NAME);
  await SaveUrlInConfigFile(FUNCTION_NAME);
}

deployLambda().catch(console.error);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-deploy-lambda.html">deploy-lambda</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Nov 05 2024 02:30:45 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
